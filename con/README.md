[![license: MIT/Apache-2.0](https://img.shields.io/badge/license-MIT%2FApache--2.0-blue.svg)](LICENSE-MIT)
[![crates.io](https://img.shields.io/crates/v/con.svg)](https://crates.io/crates/con)
[![docs.rs](https://docs.rs/con/badge.svg)](https://docs.rs/con)

# con

`con` provides attribute macros like `#[con::spec]` used to mark trait implementations that should have corresponding trait definitions generated in consumer crates.

This crate has zero dependencies and does not perform any token transformations - it simply provides the attribute definitions that the `con-cli` tool looks for when generating consumer crates.

## Usage

Slap `#[con::spec]` on impl blocks whose trait you want `con-cli` to genaerte:

```rust
#[con::spec]
impl Mod for ModImpl {
    /// Parses command line arguments
    fn parse(&self) -> Args {
        Args::parse()
    }
}
```

> **Warning**
> Only dyn-compatible traits can be marked with `#[con::spec]` â€” dynamic dispatch
> is kinda the whole point.

Traits generated by `con` are `Send + Sync + 'static` by default. If you need a trait to be
not sync, you can pass `nonsync` as an arugment to `con::spec`:

```rust
#[con::spec]
impl Foo for FooImpl {}

// will generate:
// trait Foo: Send + Sync + 'static { }

#[con::spec(nonsync)]
impl Bar for BarImpl {}

// will generate:
// trait Bar: Send + 'static { }
```

The `Mod` trait has special treatment: the concrete type `ModImpl` must implement `Default`,
because it must be able to be constructed dynamically when the mod is loaded, from no arguments.

`con-cli` will make sure that:

  * In the `mod` crate, there's an exported function that returns a `Box<dyn ModImpl>`
  * In the `con` crate, there is code (leveraging [con-loader](https://crates.io/crates/con-loader))
    that knows how to build, load, and return a `Box<dyn Mod>`.

If you need your initialization to take arguments, you can simply export two interfaces:

```rust
#[con::spec]
impl Mod for ModImpl {
    type Error = anyhow::Error;

    fn make_client(&self, endpoint: &str) -> Result<Box<dyn Client>, Self::Error> {
        let client = ClientImpl::new(endpoint)?;
        Ok(Box::new(client))
    }

    fn parse_args(&self) -> Args {
        // ...
    }
}

#[con::spec]
impl Client for ClientImpl {
    fn send_request(&self, request: Request) -> Result<Response, anyhow::Error> {
        // ...
    }
}
```

## Limitations

con will expect all your exported traits to be
